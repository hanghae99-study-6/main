## TDD 11 ~ 15장 정리

### 11장 - 모든 악의 근원

- 이 테스트를 지워도 될 정도로 다른 곳에서 동치성 테스트를 충분히 하고 있는가? 다른 동치성 테스트를 한번 보자.
- 하위 클래스의 속을 들어내는 걸 완료하고, 하위 클래스를 삭제했다.-기존의 소스 구조에서는 필요했지만, 새로운 구조에서는 필요 없게 된 테스트를 제거했다.

### 12장 - 드디어, 더하기
- 가지고 있는 객체가 우리가 원하는 방식으로 동작하지 않을 경우엔 그 객체와 외부 프로토콜이 같으면서 내부 구현은 다른 새로운 객체(imposter, 타인을 사칭하는 사기꾼)를 만들 수 있다.
- TDD는 적절한 때에 번뜩이는 통찰을 보장하지 못한다. 그렇지만 확신을 주는 테스트와 조심스럽게 정리된 코드를 통해, 통찰에 대한 준비와 함께 통찰이 번뜩일 때 그걸 적용할 준비를
할 수 있다.클래스로 만들어도 되겠지만 인터페이스가 더 가볍다.이제 컴파일이 되고, 바로 실패한다. 만세! 진전이다. 간단히 가짜 구현을 할 수 있다.다시 초록 막대로 돌아왔고 리팩토링할 준비가
됐다.
- 큰 테스트를 작은 테스트로 줄여서 발전을 나타낼 수 있도록 했다.
- 우리에게 필요한 계산에 대한 가능한 메타포들을 신중히 생각해봤다.
- 새 메타포에 기반하여 기존의 테스트를 재작성했다.
- 테스트를 빠르게 컴파일했다.
- 그리고 테스트를 실행했다.
- 진짜 구현을 만들기 위해 필요한 리팩토링을 약간의 전율과 함께 기대했다.

### 13장 - 진짜로 만들기
이 코드는 다음 두 가지 이유로 지저분하다.
- 캐스팅(형변환). 이 코드는 모든 Expression에 대해 작동해야 한다.
- 공용(public) 필드와 그 필드에 대한 두 단계에 걸친 레퍼런스.클래스를 명시적으로 검사하는 코드가 있을 때에는 항상 다형성(polymorphism)을 사용하도록 바꾸는 것이 좋다.
- 모든 중복이 제거되기 전까지는 테스트를 통과한 것으로 치지 않았다.
- 앞으로 필요할 것으로 예상되는 객체의 생성을 강요하기 위한 테스트를 작성했다.
- 일단 한 곳에 캐스팅을 이용해서 코드를 구현했다가, 테스트가 돌아가자 그 코드를 적당한 자리로 옮겼다.
- 명시적인 클래스 검사를 제거하기 위해 다형성을 사용했다.

### 14장 - 바꾸기 
- 하지만 지금은 리팩토링하는 중에 코드를 작성하는 것이기 때문에 테스트를 작성하지는 않을 것이다. 우리가 이 리팩토링을 마치고 모든 테스트가 통과한다면, 그때 우리는 그 코드가 실제로 사용되었다고 생각할 수 있다.
- 0은 최악의 해시 코드다. 하지만 구현하기 쉽고 우리가 빨리 달릴 수 있도록 도와준다는 장점이 있다. 해시 코드를 이대로 둔다면 해시 테이블에서의 검색이 마치 선형 검색과 비슷하게 수행될 것이다.나중에 코드를 읽어볼 다른 사람들에게도 알려주기 위해 테스트로 만들어 두자.
- 코드와 테스트 사이에 있는 데이터 중복을 끄집어 냈다.
- 별도의 테스트 없이 전용(private) 도우미(helper) 클래스를 만들었다.
- 리팩토링하다가 실수를 했고, 그 문제를 분리하기 위해 또 하나의 테스트를 작성하면서 계속 전진해 가기로 선택했다.

### 15장 - 서로 다른 통화 더하기
- 처음 코드 수정이 다음으로 계속해서 퍼져나갈 수 있도록 할 것이다. 앞으로 나아갈 수 있는 두 갈래 길이 있다. 좁은 범위의 한정적인 테스트를 빠르게 작성한 후에 일반화하는 방법도 있고, 우리의 모든 실수를 컴파일러가 잡아줄 거라 믿고 진행하는 방법도 있다.
- 컴포지트(Composite) 패턴
- 좀더 추상적인 선언을 통해 가지에서 뿌리(애초의 테스트 케이스)로 일반화했다.
- 변경 후, 그 영향을 받은 다른 부분들을 변경하기 위해 컴파일러의 지시를 따랐다.